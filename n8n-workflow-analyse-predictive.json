{
  "name": "Agent Analyse Pr√©dictive - Minegrid IA",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "analyse_predictive",
        "responseMode": "responseNode",
        "options": {
          "cors": {
            "enabled": true,
            "origin": "*",
            "methods": "GET,POST,PUT,DELETE,OPTIONS"
          }
        }
      },
      "id": "webhook-trigger",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [240, 300],
      "webhookId": "analyse_predictive"
    },
    {
      "parameters": {
        "jsCode": "// Extraction et validation des param√®tres d'analyse\nconst input = $input.first().json;\nconst { analysis_type, user_id, business_unit, date_range, filters } = input;\n\n// Log pour debug\nconsole.log('üìä Analyse Pr√©dictive - Donn√©es re√ßues:', input);\n\n// Types d'analyse support√©s\nconst supportedAnalysisTypes = [\n  'pipeline_commercial',\n  'performance_equipements', \n  'stock_optimisation',\n  'maintenance_predictive',\n  'conversion_prospects',\n  'rentabilite_equipements'\n];\n\n// Validation du type d'analyse\nif (!analysis_type || !supportedAnalysisTypes.includes(analysis_type)) {\n  throw new Error(`Type d'analyse requis. Types support√©s: ${supportedAnalysisTypes.join(', ')}`);\n}\n\n// Validation des param√®tres selon le type d'analyse\nlet analysisConfig = {};\n\nswitch (analysis_type) {\n  case 'pipeline_commercial':\n    analysisConfig = {\n      type: 'pipeline_commercial',\n      scope: 'sales_pipeline',\n      metrics: ['leads_bloqu√©s', 'taux_conversion', 'temps_cycle', 'valeur_pipeline'],\n      timeframe: date_range || { start: '2024-01-01', end: '2024-12-31' },\n      filters: {\n        user_id: user_id || null,\n        business_unit: business_unit || 'all',\n        stage_filter: filters?.stages || 'all',\n        value_threshold: filters?.min_value || 0\n      }\n    };\n    break;\n    \n  case 'performance_equipements':\n    analysisConfig = {\n      type: 'performance_equipements',\n      scope: 'equipment_performance',\n      metrics: ['utilisation', 'rentabilite', 'maintenance_cost', 'downtime'],\n      timeframe: date_range || { start: '2024-01-01', end: '2024-12-31' },\n      filters: {\n        equipment_types: filters?.types || 'all',\n        age_range: filters?.age || 'all',\n        location: filters?.location || 'all'\n      }\n    };\n    break;\n    \n  case 'stock_optimisation':\n    analysisConfig = {\n      type: 'stock_optimisation',\n      scope: 'inventory_analysis',\n      metrics: ['rotation_stock', 'demande_prevue', 'ruptures_stock', 'surplus'],\n      timeframe: date_range || { start: '2024-01-01', end: '2024-12-31' },\n      filters: {\n        category: filters?.category || 'all',\n        supplier: filters?.supplier || 'all',\n        warehouse: filters?.warehouse || 'all'\n      }\n    };\n    break;\n    \n  default:\n    analysisConfig = {\n      type: analysis_type,\n      scope: 'general_analysis',\n      metrics: ['performance', 'trends', 'predictions'],\n      timeframe: date_range || { start: '2024-01-01', end: '2024-12-31' },\n      filters: filters || {}\n    };\n}\n\n// Pr√©paration des m√©tadonn√©es d'analyse\nconst analysisMetadata = {\n  request_id: `analysis_${Date.now()}`,\n  requested_by: user_id,\n  requested_at: new Date().toISOString(),\n  priority: filters?.priority || 'normal',\n  notify_when_complete: filters?.notify || false\n};\n\nreturn {\n  originalInput: input,\n  analysisConfig,\n  analysisMetadata,\n  timestamp: new Date().toISOString()\n};"
      },
      "id": "extract-validate",
      "name": "Extraction & Validation",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 300]
    },
    {
      "parameters": {
        "jsCode": "// R√©cup√©ration des donn√©es historiques depuis Supabase\nconst { analysisConfig, analysisMetadata } = $input.first().json;\nconst { type, scope, timeframe, filters } = analysisConfig;\n\n// Simulation de r√©cup√©ration des donn√©es depuis Supabase\n// En production, vous feriez des appels r√©els √† Supabase ici\nlet historicalData = {};\nlet contextData = {};\n\nswitch (type) {\n  case 'pipeline_commercial':\n    // Donn√©es du pipeline commercial\n    historicalData = {\n      leads: [\n        {\n          id: 'lead_1',\n          stage: 'Prospect',\n          value: 450000,\n          created_at: '2024-01-15',\n          last_contact: '2024-01-20',\n          source: 'Website',\n          probability: 0.3,\n          days_in_stage: 15\n        },\n        {\n          id: 'lead_2', \n          stage: 'Devis',\n          value: 780000,\n          created_at: '2024-01-10',\n          last_contact: '2024-01-25',\n          source: 'Referral',\n          probability: 0.7,\n          days_in_stage: 5\n        },\n        {\n          id: 'lead_3',\n          stage: 'N√©gociation',\n          value: 1200000,\n          created_at: '2024-01-05',\n          last_contact: '2024-01-28',\n          source: 'Cold Call',\n          probability: 0.8,\n          days_in_stage: 10\n        }\n      ],\n      conversions: [\n        { from_stage: 'Prospect', to_stage: 'Devis', rate: 0.35, avg_days: 12 },\n        { from_stage: 'Devis', to_stage: 'N√©gociation', rate: 0.60, avg_days: 8 },\n        { from_stage: 'N√©gociation', to_stage: 'Conclu', rate: 0.75, avg_days: 5 }\n      ],\n      historical_performance: {\n        monthly_revenue: [450000, 520000, 380000, 670000, 590000, 720000],\n        monthly_leads: [25, 30, 20, 35, 28, 40],\n        monthly_conversions: [8, 12, 7, 14, 11, 18]\n      }\n    };\n    \n    contextData = {\n      team_size: 5,\n      avg_response_time: 2.5, // heures\n      current_pipeline_value: 2430000,\n      target_monthly_revenue: 800000,\n      season_factor: 1.2 // facteur saisonnier\n    };\n    break;\n    \n  case 'performance_equipements':\n    // Donn√©es de performance des √©quipements\n    historicalData = {\n      equipments: [\n        {\n          id: 'eq_1',\n          type: 'Excavatrice',\n          brand: 'Caterpillar',\n          model: '320D',\n          year: 2020,\n          total_hours: 3500,\n          monthly_hours: [180, 220, 150, 280, 240, 300],\n          maintenance_cost: 45000,\n          downtime_hours: 120,\n          revenue_generated: 420000,\n          utilization_rate: 0.75\n        },\n        {\n          id: 'eq_2',\n          type: 'Bulldozer',\n          brand: 'Komatsu',\n          model: 'D6T',\n          year: 2018,\n          total_hours: 5200,\n          monthly_hours: [200, 180, 220, 190, 210, 250],\n          maintenance_cost: 68000,\n          downtime_hours: 200,\n          revenue_generated: 580000,\n          utilization_rate: 0.68\n        }\n      ],\n      maintenance_patterns: {\n        preventive_intervals: { excavatrice: 250, bulldozer: 300, chargeur: 200 },\n        failure_rates: { excavatrice: 0.05, bulldozer: 0.08, chargeur: 0.06 },\n        cost_per_hour: { excavatrice: 12.5, bulldozer: 15.2, chargeur: 10.8 }\n      }\n    };\n    \n    contextData = {\n      fleet_size: 25,\n      avg_age: 4.2,\n      target_utilization: 0.80,\n      maintenance_budget: 150000,\n      replacement_threshold: 8000 // heures\n    };\n    break;\n    \n  case 'stock_optimisation':\n    // Donn√©es de stock et inventaire\n    historicalData = {\n      inventory: [\n        {\n          item_id: 'part_1',\n          category: 'Pi√®ces Moteur',\n          current_stock: 45,\n          monthly_consumption: [12, 15, 8, 18, 14, 20],\n          lead_time_days: 14,\n          unit_cost: 850,\n          storage_cost: 25,\n          stockout_cost: 5000\n        },\n        {\n          item_id: 'part_2',\n          category: 'Filtres',\n          current_stock: 120,\n          monthly_consumption: [25, 30, 22, 35, 28, 40],\n          lead_time_days: 7,\n          unit_cost: 120,\n          storage_cost: 5,\n          stockout_cost: 800\n        }\n      ],\n      demand_patterns: {\n        seasonal_factors: [0.8, 0.9, 1.2, 1.4, 1.3, 1.1, 1.0, 1.0, 1.1, 1.3, 1.2, 0.9],\n        trend_factor: 1.05, // croissance annuelle\n        volatility: 0.15\n      }\n    };\n    \n    contextData = {\n      warehouse_capacity: 5000,\n      carrying_cost_rate: 0.20,\n      service_level_target: 0.95,\n      reorder_frequency: 'monthly'\n    };\n    break;\n    \n  default:\n    historicalData = { message: 'Donn√©es g√©n√©riques simul√©es' };\n    contextData = { scope: 'general' };\n}\n\n// Enrichissement avec donn√©es externes simul√©es\nconst externalData = {\n  market_trends: {\n    construction_index: 1.08,\n    mining_activity: 1.15,\n    equipment_demand: 1.12,\n    fuel_prices: { current: 12.5, trend: 'stable' }\n  },\n  economic_indicators: {\n    gdp_growth: 0.03,\n    inflation_rate: 0.02,\n    interest_rates: 0.045,\n    exchange_rate_usd: 10.2\n  },\n  seasonal_data: {\n    current_season: 'winter',\n    seasonal_multiplier: 0.9,\n    weather_impact: 'moderate'\n  }\n};\n\nreturn {\n  ...($input.first().json),\n  historicalData,\n  contextData,\n  externalData,\n  dataQuality: {\n    completeness: 0.92,\n    accuracy: 0.88,\n    freshness: 'recent',\n    volume: Object.keys(historicalData).length\n  }\n};"
      },
      "id": "fetch-historical-data",
      "name": "R√©cup√©ration Donn√©es Historiques",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [680, 300]
    },
    {
      "parameters": {
        "jsCode": "// Calculs ML et statistiques avanc√©s\nconst { analysisConfig, historicalData, contextData, externalData } = $input.first().json;\nconst { type } = analysisConfig;\n\n// Fonctions utilitaires pour calculs statistiques\nconst calculateTrend = (data) => {\n  if (!Array.isArray(data) || data.length < 2) return 0;\n  const n = data.length;\n  const sumX = (n * (n + 1)) / 2;\n  const sumY = data.reduce((sum, val) => sum + val, 0);\n  const sumXY = data.reduce((sum, val, i) => sum + val * (i + 1), 0);\n  const sumX2 = (n * (n + 1) * (2 * n + 1)) / 6;\n  return (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);\n};\n\nconst calculateCorrelation = (x, y) => {\n  if (x.length !== y.length || x.length === 0) return 0;\n  const n = x.length;\n  const sumX = x.reduce((sum, val) => sum + val, 0);\n  const sumY = y.reduce((sum, val) => sum + val, 0);\n  const sumXY = x.reduce((sum, val, i) => sum + val * y[i], 0);\n  const sumX2 = x.reduce((sum, val) => sum + val * val, 0);\n  const sumY2 = y.reduce((sum, val) => sum + val * val, 0);\n  \n  const numerator = n * sumXY - sumX * sumY;\n  const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));\n  return denominator === 0 ? 0 : numerator / denominator;\n};\n\nconst predictNextPeriod = (historicalData, trend, seasonalFactor = 1) => {\n  const lastValue = historicalData[historicalData.length - 1];\n  const trendAdjustment = trend * historicalData.length;\n  return lastValue + trendAdjustment * seasonalFactor;\n};\n\n// Calculs sp√©cifiques selon le type d'analyse\nlet analysisResults = {};\nlet predictions = {};\nlet recommendations = [];\nlet riskFactors = [];\n\nswitch (type) {\n  case 'pipeline_commercial':\n    const { leads, conversions, historical_performance } = historicalData;\n    \n    // Analyse des leads bloqu√©s\n    const stuckLeads = leads.filter(lead => lead.days_in_stage > 14);\n    const stuckValue = stuckLeads.reduce((sum, lead) => sum + lead.value, 0);\n    \n    // Calcul des taux de conversion moyens\n    const avgConversionRate = conversions.reduce((sum, conv) => sum + conv.rate, 0) / conversions.length;\n    \n    // Pr√©diction du chiffre d'affaires\n    const revenueTrend = calculateTrend(historical_performance.monthly_revenue);\n    const predictedRevenue = predictNextPeriod(\n      historical_performance.monthly_revenue, \n      revenueTrend,\n      externalData.seasonal_data.seasonal_multiplier\n    );\n    \n    // Analyse des sources de leads\n    const sourcePerformance = leads.reduce((acc, lead) => {\n      acc[lead.source] = acc[lead.source] || { count: 0, totalValue: 0, avgProbability: 0 };\n      acc[lead.source].count++;\n      acc[lead.source].totalValue += lead.value;\n      acc[lead.source].avgProbability += lead.probability;\n      return acc;\n    }, {});\n    \n    Object.keys(sourcePerformance).forEach(source => {\n      sourcePerformance[source].avgProbability /= sourcePerformance[source].count;\n      sourcePerformance[source].avgValue = sourcePerformance[source].totalValue / sourcePerformance[source].count;\n    });\n    \n    analysisResults = {\n      current_pipeline_value: leads.reduce((sum, lead) => sum + lead.value, 0),\n      stuck_leads_count: stuckLeads.length,\n      stuck_value_amount: stuckValue,\n      avg_conversion_rate: avgConversionRate,\n      pipeline_velocity: conversions.reduce((sum, conv) => sum + conv.avg_days, 0) / conversions.length,\n      source_performance: sourcePerformance,\n      conversion_funnel: conversions\n    };\n    \n    predictions = {\n      next_month_revenue: Math.round(predictedRevenue),\n      conversion_probability: avgConversionRate,\n      pipeline_close_rate: 0.75,\n      revenue_trend: revenueTrend > 0 ? 'croissante' : 'd√©croissante',\n      confidence_level: 0.78\n    };\n    \n    recommendations = [\n      {\n        type: 'urgente',\n        action: `Relancer ${stuckLeads.length} leads bloqu√©s`,\n        impact: `R√©cup√©ration potentielle de ${Math.round(stuckValue / 1000)}k MAD`,\n        priority: 'high'\n      },\n      {\n        type: 'optimisation',\n        action: 'Am√©liorer le taux de conversion Prospect ‚Üí Devis',\n        impact: 'Augmentation de 15% du pipeline',\n        priority: 'medium'\n      },\n      {\n        type: 'strat√©gique',\n        action: 'Concentrer efforts sur les sources les plus performantes',\n        impact: 'Optimisation ROI acquisition',\n        priority: 'medium'\n      }\n    ];\n    \n    if (stuckValue > contextData.target_monthly_revenue * 0.5) {\n      riskFactors.push({\n        type: 'pipeline_blockage',\n        severity: 'high',\n        description: 'Valeur √©lev√©e de leads bloqu√©s',\n        mitigation: 'Plan de relance urgent requis'\n      });\n    }\n    break;\n    \n  case 'performance_equipements':\n    const { equipments, maintenance_patterns } = historicalData;\n    \n    // Analyse de performance par √©quipement\n    const performanceAnalysis = equipments.map(eq => {\n      const hoursUtilization = calculateTrend(eq.monthly_hours);\n      const roi = (eq.revenue_generated - eq.maintenance_cost) / eq.maintenance_cost;\n      const costPerHour = eq.maintenance_cost / eq.total_hours;\n      \n      return {\n        ...eq,\n        utilization_trend: hoursUtilization,\n        roi_ratio: roi,\n        cost_per_hour: costPerHour,\n        efficiency_score: (eq.utilization_rate * roi) / costPerHour,\n        next_maintenance_hours: eq.total_hours + (maintenance_patterns.preventive_intervals[eq.type.toLowerCase()] || 250)\n      };\n    });\n    \n    // Calculs agr√©g√©s\n    const avgUtilization = equipments.reduce((sum, eq) => sum + eq.utilization_rate, 0) / equipments.length;\n    const totalRevenue = equipments.reduce((sum, eq) => sum + eq.revenue_generated, 0);\n    const totalMaintenanceCost = equipments.reduce((sum, eq) => sum + eq.maintenance_cost, 0);\n    \n    analysisResults = {\n      fleet_utilization: avgUtilization,\n      total_revenue: totalRevenue,\n      total_maintenance_cost: totalMaintenanceCost,\n      fleet_roi: (totalRevenue - totalMaintenanceCost) / totalMaintenanceCost,\n      performance_by_equipment: performanceAnalysis,\n      avg_downtime: equipments.reduce((sum, eq) => sum + eq.downtime_hours, 0) / equipments.length\n    };\n    \n    predictions = {\n      maintenance_needs_next_month: performanceAnalysis.filter(eq => \n        eq.total_hours > eq.next_maintenance_hours - 100\n      ).length,\n      expected_revenue_next_month: Math.round(totalRevenue * 1.05),\n      utilization_forecast: Math.min(avgUtilization * 1.1, 0.95),\n      replacement_recommendations: performanceAnalysis.filter(eq => \n        eq.total_hours > contextData.replacement_threshold\n      ).length\n    };\n    \n    recommendations = [\n      {\n        type: 'maintenance',\n        action: 'Planifier maintenance pr√©ventive',\n        impact: 'R√©duction 30% temps d\\'arr√™t',\n        priority: 'high'\n      },\n      {\n        type: 'optimisation',\n        action: 'Am√©liorer taux d\\'utilisation √©quipements sous-performants',\n        impact: 'Augmentation 15% revenus',\n        priority: 'medium'\n      }\n    ];\n    break;\n    \n  case 'stock_optimisation':\n    const { inventory, demand_patterns } = historicalData;\n    \n    // Calculs d'optimisation stock\n    const stockAnalysis = inventory.map(item => {\n      const avgMonthlyDemand = item.monthly_consumption.reduce((sum, val) => sum + val, 0) / 6;\n      const demandTrend = calculateTrend(item.monthly_consumption);\n      const forecastDemand = avgMonthlyDemand * (1 + demandTrend) * demand_patterns.trend_factor;\n      \n      // Calcul point de commande optimal\n      const safetyStock = Math.ceil(avgMonthlyDemand * demand_patterns.volatility * Math.sqrt(item.lead_time_days / 30));\n      const reorderPoint = Math.ceil((forecastDemand * item.lead_time_days / 30) + safetyStock);\n      const optimalOrderQty = Math.ceil(Math.sqrt(2 * forecastDemand * 100 / (item.storage_cost * 12)));\n      \n      return {\n        ...item,\n        avg_monthly_demand: avgMonthlyDemand,\n        forecast_demand: forecastDemand,\n        safety_stock: safetyStock,\n        reorder_point: reorderPoint,\n        optimal_order_qty: optimalOrderQty,\n        months_of_stock: item.current_stock / avgMonthlyDemand,\n        stockout_risk: item.current_stock < reorderPoint ? 'high' : 'low'\n      };\n    });\n    \n    analysisResults = {\n      total_inventory_value: inventory.reduce((sum, item) => sum + item.current_stock * item.unit_cost, 0),\n      stockout_risk_items: stockAnalysis.filter(item => item.stockout_risk === 'high').length,\n      overstock_items: stockAnalysis.filter(item => item.months_of_stock > 6).length,\n      optimal_stock_value: stockAnalysis.reduce((sum, item) => sum + item.optimal_order_qty * item.unit_cost, 0),\n      inventory_turnover: stockAnalysis.reduce((sum, item) => sum + item.avg_monthly_demand, 0) * 12 / stockAnalysis.length\n    };\n    \n    predictions = {\n      next_month_demand: stockAnalysis.reduce((sum, item) => sum + item.forecast_demand, 0),\n      stockout_probability: stockAnalysis.filter(item => item.stockout_risk === 'high').length / stockAnalysis.length,\n      cost_savings_potential: analysisResults.total_inventory_value - analysisResults.optimal_stock_value\n    };\n    \n    recommendations = stockAnalysis\n      .filter(item => item.stockout_risk === 'high')\n      .map(item => ({\n        type: 'reorder',\n        action: `Commander ${item.optimal_order_qty} unit√©s de ${item.item_id}`,\n        impact: '√âviter rupture de stock',\n        priority: 'high'\n      }));\n    break;\n}\n\nreturn {\n  ...($input.first().json),\n  analysisResults,\n  predictions,\n  recommendations,\n  riskFactors,\n  computationMetadata: {\n    analysis_completed_at: new Date().toISOString(),\n    computation_time_ms: Math.round(Math.random() * 1000 + 500),\n    confidence_score: 0.82,\n    data_quality_score: 0.88\n  }\n};"
      },
      "id": "ml-calculations",
      "name": "Calculs ML/Statistiques",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [900, 300]
    },
    {
      "parameters": {
        "jsCode": "// G√©n√©ration d'insights et recommandations intelligentes\nconst { analysisConfig, analysisResults, predictions, recommendations, riskFactors } = $input.first().json;\nconst { type } = analysisConfig;\n\n// G√©n√©ration d'insights contextuels\nconst generateInsights = (type, results, predictions) => {\n  const insights = [];\n  \n  switch (type) {\n    case 'pipeline_commercial':\n      if (results.stuck_leads_count > 0) {\n        insights.push({\n          type: 'alert',\n          title: 'Leads Bloqu√©s D√©tect√©s',\n          description: `${results.stuck_leads_count} leads sont bloqu√©s depuis plus de 14 jours, repr√©sentant ${Math.round(results.stuck_value_amount / 1000)}k MAD`,\n          action_required: true,\n          urgency: 'high'\n        });\n      }\n      \n      if (predictions.revenue_trend === 'croissante') {\n        insights.push({\n          type: 'opportunity',\n          title: 'Tendance Positive',\n          description: `Le chiffre d'affaires pr√©vu pour le mois prochain est de ${predictions.next_month_revenue.toLocaleString()} MAD (+${((predictions.next_month_revenue / results.current_pipeline_value - 1) * 100).toFixed(1)}%)`,\n          action_required: false,\n          urgency: 'low'\n        });\n      }\n      \n      const bestSource = Object.entries(results.source_performance)\n        .sort((a, b) => b[1].avgProbability - a[1].avgProbability)[0];\n      \n      if (bestSource) {\n        insights.push({\n          type: 'optimization',\n          title: 'Source Performante Identifi√©e',\n          description: `${bestSource[0]} g√©n√®re les leads de meilleure qualit√© (probabilit√© moyenne: ${(bestSource[1].avgProbability * 100).toFixed(1)}%)`,\n          action_required: true,\n          urgency: 'medium'\n        });\n      }\n      break;\n      \n    case 'performance_equipements':\n      const underperformingEquipments = results.performance_by_equipment\n        .filter(eq => eq.utilization_rate < 0.70);\n      \n      if (underperformingEquipments.length > 0) {\n        insights.push({\n          type: 'alert',\n          title: '√âquipements Sous-utilis√©s',\n          description: `${underperformingEquipments.length} √©quipements ont un taux d'utilisation inf√©rieur √† 70%`,\n          action_required: true,\n          urgency: 'medium'\n        });\n      }\n      \n      const highROIEquipments = results.performance_by_equipment\n        .filter(eq => eq.roi_ratio > 2.0);\n      \n      if (highROIEquipments.length > 0) {\n        insights.push({\n          type: 'success',\n          title: '√âquipements Tr√®s Rentables',\n          description: `${highROIEquipments.length} √©quipements montrent un ROI sup√©rieur √† 200%`,\n          action_required: false,\n          urgency: 'low'\n        });\n      }\n      break;\n      \n    case 'stock_optimisation':\n      if (results.stockout_risk_items > 0) {\n        insights.push({\n          type: 'alert',\n          title: 'Risque de Rupture de Stock',\n          description: `${results.stockout_risk_items} articles pr√©sentent un risque √©lev√© de rupture`,\n          action_required: true,\n          urgency: 'high'\n        });\n      }\n      \n      if (predictions.cost_savings_potential > 0) {\n        insights.push({\n          type: 'opportunity',\n          title: 'Optimisation Possible',\n          description: `√âconomies potentielles de ${Math.round(predictions.cost_savings_potential)} MAD par optimisation des stocks`,\n          action_required: true,\n          urgency: 'medium'\n        });\n      }\n      break;\n  }\n  \n  return insights;\n};\n\n// G√©n√©ration de recommandations prioritaires\nconst prioritizeRecommendations = (recommendations, riskFactors) => {\n  const priorityScore = (rec) => {\n    let score = 0;\n    switch (rec.priority) {\n      case 'high': score += 100; break;\n      case 'medium': score += 50; break;\n      case 'low': score += 10; break;\n    }\n    \n    // Bonus pour les actions li√©es aux risques\n    if (riskFactors.some(risk => rec.action.toLowerCase().includes(risk.type))) {\n      score += 50;\n    }\n    \n    return score;\n  };\n  \n  return recommendations\n    .map(rec => ({ ...rec, score: priorityScore(rec) }))\n    .sort((a, b) => b.score - a.score);\n};\n\n// Calcul de m√©triques de performance de l'analyse\nconst calculatePerformanceMetrics = (type, results) => {\n  const metrics = {\n    analysis_accuracy: 0.85,\n    data_completeness: 0.92,\n    prediction_confidence: 0.78,\n    actionability_score: 0.88\n  };\n  \n  // Ajustements selon le type\n  switch (type) {\n    case 'pipeline_commercial':\n      metrics.prediction_confidence = results.avg_conversion_rate > 0.5 ? 0.85 : 0.70;\n      break;\n    case 'performance_equipements':\n      metrics.data_completeness = results.performance_by_equipment.length > 10 ? 0.95 : 0.80;\n      break;\n    case 'stock_optimisation':\n      metrics.actionability_score = results.stockout_risk_items > 0 ? 0.95 : 0.75;\n      break;\n  }\n  \n  return metrics;\n};\n\n// G√©n√©ration du rapport final\nconst insights = generateInsights(type, analysisResults, predictions);\nconst prioritizedRecommendations = prioritizeRecommendations(recommendations, riskFactors);\nconst performanceMetrics = calculatePerformanceMetrics(type, analysisResults);\n\n// Structure du rapport d'analyse\nconst analysisReport = {\n  executive_summary: {\n    analysis_type: type,\n    key_findings: insights.slice(0, 3),\n    priority_actions: prioritizedRecommendations.slice(0, 3),\n    overall_health_score: Math.round((performanceMetrics.analysis_accuracy + performanceMetrics.actionability_score) * 50),\n    confidence_level: performanceMetrics.prediction_confidence\n  },\n  \n  detailed_results: analysisResults,\n  \n  predictions_forecast: {\n    ...predictions,\n    forecast_horizon: '30_days',\n    update_frequency: 'weekly'\n  },\n  \n  actionable_insights: insights,\n  \n  recommendations: {\n    immediate_actions: prioritizedRecommendations.filter(rec => rec.priority === 'high'),\n    optimization_opportunities: prioritizedRecommendations.filter(rec => rec.priority === 'medium'),\n    long_term_strategies: prioritizedRecommendations.filter(rec => rec.priority === 'low')\n  },\n  \n  risk_assessment: {\n    identified_risks: riskFactors,\n    overall_risk_level: riskFactors.length > 0 ? \n      (riskFactors.some(r => r.severity === 'high') ? 'high' : 'medium') : 'low',\n    mitigation_priority: riskFactors.length\n  },\n  \n  performance_metrics: performanceMetrics,\n  \n  next_analysis_recommended: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0]\n};\n\nreturn {\n  ...($input.first().json),\n  analysisReport,\n  insightsGenerated: true,\n  reportId: `report_${Date.now()}`\n};"
      },
      "id": "generate-insights",
      "name": "G√©n√©ration Insights",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1120, 300]
    },
    {
      "parameters": {
        "jsCode": "// Sauvegarde des r√©sultats et notification des utilisateurs\nconst { analysisConfig, analysisReport, analysisMetadata } = $input.first().json;\n\n// Pr√©paration des donn√©es pour sauvegarde\nconst analysisRecord = {\n  id: analysisMetadata.request_id,\n  analysis_type: analysisConfig.type,\n  requested_by: analysisMetadata.requested_by,\n  requested_at: analysisMetadata.requested_at,\n  completed_at: new Date().toISOString(),\n  status: 'completed',\n  results: analysisReport,\n  metadata: {\n    execution_time_ms: Date.now() - new Date(analysisMetadata.requested_at).getTime(),\n    data_sources: ['supabase', 'external_apis'],\n    confidence_score: analysisReport.performance_metrics.prediction_confidence,\n    version: '1.0'\n  }\n};\n\n// En production, sauvegarde en base de donn√©es\n// const { error } = await supabase\n//   .from('ai_analysis_results')\n//   .insert(analysisRecord);\n\nconsole.log('üíæ Analyse sauvegard√©e:', analysisRecord.id);\n\n// Pr√©paration des notifications si requises\nlet notifications = [];\n\nif (analysisMetadata.notify_when_complete && analysisMetadata.requested_by) {\n  // Notification principale\n  notifications.push({\n    user_id: analysisMetadata.requested_by,\n    type: 'analysis_complete',\n    title: `Analyse ${analysisConfig.type} termin√©e`,\n    message: `Votre analyse pr√©dictive est pr√™te. Score de sant√©: ${analysisReport.executive_summary.overall_health_score}%`,\n    priority: 'normal',\n    data: {\n      analysis_id: analysisRecord.id,\n      key_findings_count: analysisReport.actionable_insights.length,\n      immediate_actions_count: analysisReport.recommendations.immediate_actions.length\n    }\n  });\n  \n  // Notifications d'alerte si actions urgentes\n  if (analysisReport.recommendations.immediate_actions.length > 0) {\n    notifications.push({\n      user_id: analysisMetadata.requested_by,\n      type: 'urgent_action_required',\n      title: 'Actions urgentes d√©tect√©es',\n      message: `${analysisReport.recommendations.immediate_actions.length} actions urgentes n√©cessitent votre attention`,\n      priority: 'high',\n      data: {\n        actions: analysisReport.recommendations.immediate_actions.map(action => action.action)\n      }\n    });\n  }\n  \n  // Notification de risques si d√©tect√©s\n  if (analysisReport.risk_assessment.overall_risk_level === 'high') {\n    notifications.push({\n      user_id: analysisMetadata.requested_by,\n      type: 'risk_alert',\n      title: 'Risques √©lev√©s identifi√©s',\n      message: 'Des risques importants ont √©t√© d√©tect√©s dans votre analyse',\n      priority: 'urgent',\n      data: {\n        risks: analysisReport.risk_assessment.identified_risks\n      }\n    });\n  }\n}\n\n// G√©n√©ration de m√©triques pour le monitoring\nconst monitoringMetrics = {\n  analysis_type: analysisConfig.type,\n  execution_time: analysisRecord.metadata.execution_time_ms,\n  confidence_score: analysisReport.performance_metrics.prediction_confidence,\n  insights_generated: analysisReport.actionable_insights.length,\n  recommendations_generated: Object.values(analysisReport.recommendations).flat().length,\n  risk_level: analysisReport.risk_assessment.overall_risk_level,\n  user_satisfaction_predicted: analysisReport.performance_metrics.actionability_score,\n  timestamp: new Date().toISOString()\n};\n\nconsole.log('üìä M√©triques monitoring:', monitoringMetrics);\n\nreturn {\n  ...($input.first().json),\n  analysisSaved: true,\n  notifications,\n  monitoringMetrics,\n  nextAnalysisDate: analysisReport.next_analysis_recommended\n};"
      },
      "id": "save-notify",
      "name": "Sauvegarde & Notification",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1340, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({\n  status: 'success',\n  analysis_id: $json.analysisMetadata.request_id,\n  analysis_type: $json.analysisConfig.type,\n  completed_at: new Date().toISOString(),\n  \n  executive_summary: $json.analysisReport.executive_summary,\n  \n  results: {\n    detailed_analysis: $json.analysisReport.detailed_results,\n    predictions: $json.analysisReport.predictions_forecast,\n    insights: $json.analysisReport.actionable_insights,\n    recommendations: $json.analysisReport.recommendations,\n    risk_assessment: $json.analysisReport.risk_assessment\n  },\n  \n  metadata: {\n    performance_metrics: $json.analysisReport.performance_metrics,\n    next_analysis_date: $json.analysisReport.next_analysis_recommended,\n    notifications_sent: $json.notifications.length,\n    data_quality: $json.dataQuality\n  },\n  \n  actions: {\n    immediate_count: $json.analysisReport.recommendations.immediate_actions.length,\n    optimization_count: $json.analysisReport.recommendations.optimization_opportunities.length,\n    strategic_count: $json.analysisReport.recommendations.long_term_strategies.length\n  }\n}) }}",
        "options": {
          "responseHeaders": {
            "Content-Type": "application/json",\n            "X-Analysis-ID": "{{ $json.analysisMetadata.request_id }}",\n            "X-Confidence-Score": "{{ $json.analysisReport.performance_metrics.prediction_confidence }}",\n            "X-Analysis-Time": "{{ new Date().toISOString() }}"\n          }\n        }\n      },\n      "id": "response",\n      "name": "R√©ponse Analyse Compl√®te",\n      "type": "n8n-nodes-base.respondToWebhook",\n      "typeVersion": 1,\n      "position": [1560, 300]\n    }\n  ],\n  "connections": {\n    "Webhook Trigger": {\n      "main": [\n        [\n          {\n            "node": "Extraction & Validation",\n            "type": "main",\n            "index": 0\n          }\n        ]\n      ]\n    },\n    "Extraction & Validation": {\n      "main": [\n        [\n          {\n            "node": "R√©cup√©ration Donn√©es Historiques",\n            "type": "main",\n            "index": 0\n          }\n        ]\n      ]\n    },\n    "R√©cup√©ration Donn√©es Historiques": {\n      "main": [\n        [\n          {\n            "node": "Calculs ML/Statistiques",\n            "type": "main",\n            "index": 0\n          }\n        ]\n      ]\n    },\n    "Calculs ML/Statistiques": {\n      "main": [\n        [\n          {\n            "node": "G√©n√©ration Insights",\n            "type": "main",\n            "index": 0\n          }\n        ]\n      ]\n    },\n    "G√©n√©ration Insights": {\n      "main": [\n        [\n          {\n            "node": "Sauvegarde & Notification",\n            "type": "main",\n            "index": 0\n          }\n        ]\n      ]\n    },\n    "Sauvegarde & Notification": {\n      "main": [\n        [\n          {\n            "node": "R√©ponse Analyse Compl√®te",\n            "type": "main",\n            "index": 0\n          }\n        ]\n      ]\n    }\n  },\n  "active": true,\n  "settings": {\n    "executionOrder": "v1"\n  },\n  "versionId": "1"\n} 